# Robot Vision Demo - Claude Code Configuration (Enhanced)
# Task-Driven Development with Interactive Collaboration

## üéØ DEVELOPMENT PHILOSOPHY

This project follows **Task-Driven, Interface-First Development** with Claude Code as an interactive collaborator, not just a code generator.

**Core Principles:**
1. **One task at a time** - Focus, complete, test, move on
2. **Interface before implementation** - Define contracts first
3. **Specification per feature** - Living documentation
4. **Test alongside code** - Not after, during
5. **Collaborative learning** - Critique, suggest, teach

---

## üìã PHASE-TO-SPEC MAPPING

**When working on a specific phase, read ONLY the relevant spec file:**

| Phase | Spec File | Status |
|-------|-----------|--------|
| Phase 1: Foundation | `docs/specs/platform-abstraction.md` | ‚úÖ Complete |
| Phase 2: Video Pipeline | `docs/specs/video-pipeline.md` | ‚úÖ Complete |
| Phase 3: Graphics Overlay | `docs/specs/osd-rendering.md` | ‚úÖ Complete |
| Phase 4: OSD Features | `docs/specs/osd-rendering.md` | üîÑ In Progress |
| Phase 5: File Operations | `docs/specs/file-storage.md` | ‚¨ú Not Started |
| Phase 6: Testing | `docs/specs/testing.md` | ‚¨ú Not Started |

**At session start:**
1. User states which phase/task they're working on
2. Claude reads ONLY the relevant spec file
3. Keeps context minimal and focused

**Example:**
```
User: "Let's continue with Phase 4 OSD features"
Claude: *reads docs/specs/osd-rendering.md*
        *proceeds with focused context*
```

---

## ü§ù CLAUDE CODE COLLABORATION PROTOCOL

### Your Role as Collaborator

You are NOT just a code generator. You are a **senior software engineer and mentor** helping a developer who is:
- Relatively new to C++
- Learning robotics development
- Building cross-platform systems for the first time

### REQUIRED Interactive Behavior

**BEFORE starting ANY task, you MUST:**

1. **Evaluate the task**
   - Is the task well-defined?
   - Is the scope appropriate (not too big/small)?
   - Are there dependencies that should be done first?
   - Does it align with PROJECT-SPEC.md?

2. **Critique the approach**
   - Is this the best way to solve this problem?
   - Are there simpler alternatives?
   - What are the trade-offs?
   - Any potential pitfalls?

3. **Ask clarifying questions**
   - What's unclear about the requirements?
   - What context is missing?
   - What are the acceptance criteria?
   - What's the expected behavior on errors?

4. **Suggest improvements**
   - Better architectural choices
   - More maintainable patterns
   - Performance considerations
   - Testing strategies

5. **Teach the concepts**
   - Explain C++ features being used
   - Describe GStreamer/NanoVG patterns
   - Share robotics best practices
   - Point out common mistakes to avoid

### Example Interaction Pattern

**USER**: "Implement video pipeline initialization"

**YOU MUST RESPOND**:
```
Let me evaluate this task first:

**Task Analysis:**
- Scope: Good - Single responsibility (initialization)
- Dependencies: Need platform abstraction first (not yet implemented)
- Complexity: Medium - involves GStreamer API

**Questions before we proceed:**
1. Should initialization be blocking or async?
2. What should happen if camera is not available?
3. Do we need retry logic for transient failures?
4. Should we validate resolution/fps before creating pipeline?

**Suggested approach:**
Instead of implementing directly, let's:
1. First define IPipeline interface (in specs/video-pipeline.md)
2. Create PipelineConfig struct for parameters
3. Then implement initialization with error handling

**Alternative consideration:**
We could use a builder pattern for complex pipeline setup:
  PipelineBuilder().withResolution(1280,720)
                    .withFPS(30)
                    .build()
This makes configuration clearer. Thoughts?

**Learning note (C++):**
We'll use RAII for GStreamer resource management to prevent leaks.
This means...

Should I proceed with interface definition first?
```

**Only proceed after user confirms or provides feedback.**

---

## üìã TASK-DRIVEN WORKFLOW

### Task Structure

Every task follows this structure:

```markdown
## Task: [Short descriptive name]

**Context:**
- Feature area: [video, rendering, storage, etc.]
- Dependencies: [list of completed tasks]
- Related spec: docs/specs/[feature].md

**Requirements:**
1. [Specific requirement 1]
2. [Specific requirement 2]

**Interfaces needed:**
- [List of classes/functions to interact with]

**Acceptance criteria:**
- [ ] Compiles without warnings
- [ ] Tests pass
- [ ] Documented
- [ ] Spec updated
```

### Task Sizing Rules

**Good task size** (1-2 hours):
- ‚úÖ Implement single class interface
- ‚úÖ Add one feature with tests
- ‚úÖ Create platform abstraction for one component
- ‚úÖ Implement error handling for one module

**Too large** (split into smaller tasks):
- ‚ùå "Implement complete video pipeline"
- ‚ùå "Add all OSD features"
- ‚ùå "Create full platform abstraction"

**Too small** (combine with related tasks):
- ‚ùå "Add single getter function"
- ‚ùå "Fix typo in comment"

### Task Isolation Strategy

**Keep context minimal:**
```
INCLUDE:
‚úÖ Interface definitions (.h files)
‚úÖ Relevant spec section
‚úÖ Error handling requirements
‚úÖ Platform constraints

EXCLUDE:
‚ùå Implementation of other components
‚ùå Full spec document (reference specific sections)
‚ùå Unrelated features
```

**Example - Minimal Context for Task:**
```
Task: Implement GStreamer pipeline creation

Context Files:
- src/video_pipeline.h (interface only)
- src/platform/platform.h (for platform detection)
- docs/specs/video-pipeline.md (section 2: Creation)

Don't need:
- OSD renderer implementation
- Storage code
- Full PROJECT-SPEC.md
```

---

## üèóÔ∏è INTERFACE-FIRST DEVELOPMENT

### Interface Design Rules

**ALWAYS define interfaces BEFORE implementation:**

1. **Create header file with interface**
2. **Document expected behavior**
3. **Define error conditions**
4. **Get review/approval**
5. **Then implement**

### Interface Template

```cpp
#pragma once

/**
 * @file i_video_pipeline.h
 * @brief Interface for video capture and processing pipeline
 *
 * This interface abstracts platform-specific video capture,
 * allowing different implementations for macOS and Jetson.
 */

#include <memory>
#include <string>

// Forward declarations
struct Frame;
struct PipelineConfig;

/**
 * Video pipeline interface
 *
 * Implementations must handle:
 * - Platform-specific camera sources
 * - Error recovery and retry logic
 * - Resource cleanup (RAII pattern)
 */
class IVideoPipeline
{
public:
    virtual ~IVideoPipeline() = default;

    /**
     * Initialize the video pipeline
     *
     * @param config Pipeline configuration (resolution, fps, source)
     * @return true on success, false on failure
     *
     * Error conditions:
     * - Camera not available: returns false, logs error
     * - Invalid config: returns false, logs validation error
     * - GStreamer init failed: throws VideoException
     *
     * Platform notes:
     * - macOS: Uses autovideosrc
     * - Jetson: Uses nvarguscamerasrc for CSI
     */
    virtual bool initialize(const PipelineConfig& config) = 0;

    /**
     * Start video capture
     *
     * @return true if started, false if already running or failed
     *
     * Must call initialize() first, otherwise returns false
     */
    virtual bool start() = 0;

    /**
     * Get next video frame (blocking)
     *
     * @param timeout_ms Maximum time to wait for frame
     * @return Shared pointer to frame, nullptr on timeout
     *
     * Thread safety: Safe to call from single consumer thread
     * Performance: Blocks until frame available or timeout
     */
    virtual std::shared_ptr<Frame> getNextFrame(uint32_t timeout_ms = 1000) = 0;

    /**
     * Stop video capture
     *
     * Idempotent - safe to call multiple times
     * Blocks until pipeline fully stopped
     */
    virtual void stop() = 0;

    /**
     * Get current pipeline state
     *
     * @return State string: "stopped", "initializing", "running", "error"
     */
    virtual std::string getState() const = 0;
};

/**
 * Factory function for creating platform-specific pipeline
 *
 * @return Unique pointer to platform-appropriate implementation
 *
 * Platform detection is automatic based on compile-time defines
 */
std::unique_ptr<IVideoPipeline> createVideoPipeline();
```

### When to Create Interfaces

**Create interface when:**
- ‚úÖ Multiple implementations needed (platform abstraction)
- ‚úÖ Component has complex behavior to test (mockable)
- ‚úÖ Want to decouple components
- ‚úÖ Future extensibility expected

**Don't create interface when:**
- ‚ùå Single, simple implementation
- ‚ùå Pure data structure (struct/class)
- ‚ùå Utility functions

---

## üìö MODULAR CODE ORGANIZATION

### Directory Structure for Modularity

```
src/
‚îú‚îÄ‚îÄ core/                      # Core abstractions & interfaces
‚îÇ   ‚îú‚îÄ‚îÄ i_video_pipeline.h    # Video interface
‚îÇ   ‚îú‚îÄ‚îÄ i_renderer.h          # Renderer interface
‚îÇ   ‚îú‚îÄ‚îÄ i_storage.h           # Storage interface
‚îÇ   ‚îî‚îÄ‚îÄ types.h               # Common types (Frame, Config, etc.)
‚îÇ
‚îú‚îÄ‚îÄ video/                     # Video module
‚îÇ   ‚îú‚îÄ‚îÄ video_pipeline.h
‚îÇ   ‚îú‚îÄ‚îÄ video_pipeline.cpp
‚îÇ   ‚îú‚îÄ‚îÄ gstreamer_utils.h     # GStreamer-specific utilities
‚îÇ   ‚îî‚îÄ‚îÄ gstreamer_utils.cpp
‚îÇ
‚îú‚îÄ‚îÄ rendering/                 # Rendering module
‚îÇ   ‚îú‚îÄ‚îÄ osd_renderer.h
‚îÇ   ‚îú‚îÄ‚îÄ osd_renderer.cpp
‚îÇ   ‚îú‚îÄ‚îÄ nanovg_context.h      # NanoVG wrapper
‚îÇ   ‚îî‚îÄ‚îÄ nanovg_context.cpp
‚îÇ
‚îú‚îÄ‚îÄ storage/                   # Storage module
‚îÇ   ‚îú‚îÄ‚îÄ file_storage.h
‚îÇ   ‚îî‚îÄ‚îÄ file_storage.cpp
‚îÇ
‚îú‚îÄ‚îÄ platform/                  # Platform abstraction
‚îÇ   ‚îú‚îÄ‚îÄ platform.h            # Platform interface
‚îÇ   ‚îú‚îÄ‚îÄ platform_macos.cpp
‚îÇ   ‚îî‚îÄ‚îÄ platform_jetson.cpp
‚îÇ
‚îú‚îÄ‚îÄ utils/                     # Common utilities
‚îÇ   ‚îú‚îÄ‚îÄ logger.h              # Logging utility
‚îÇ   ‚îú‚îÄ‚îÄ logger.cpp
‚îÇ   ‚îú‚îÄ‚îÄ config_parser.h       # JSON config parsing
‚îÇ   ‚îú‚îÄ‚îÄ config_parser.cpp
‚îÇ   ‚îú‚îÄ‚îÄ error_handler.h       # Error handling helpers
‚îÇ   ‚îî‚îÄ‚îÄ timer.h               # Performance timing
‚îÇ
‚îî‚îÄ‚îÄ main.cpp                   # Application entry point
```

### Utility Code Guidelines

**Create utility when code is:**
1. Used by 3+ components
2. Has no dependencies on application logic
3. Could be unit tested in isolation
4. Could be reused in other projects

**Utils Categories:**

**logger.h/cpp** - Centralized logging
```cpp
namespace utils {
    enum class LogLevel { DEBUG, INFO, WARNING, ERROR };
    void log(LogLevel level, const std::string& component,
             const std::string& message);
}
```

**config_parser.h/cpp** - Configuration management
```cpp
namespace utils {
    class ConfigParser {
        static nlohmann::json loadFromFile(const std::string& path);
        static bool saveToFile(const nlohmann::json& config, const std::string& path);
    };
}
```

**error_handler.h** - Error handling helpers
```cpp
namespace utils {
    // RAII wrapper for GStreamer objects
    template<typename T>
    class GstObjectPtr { ... };

    // Error formatting
    std::string formatGstError(GError* error);
}
```

**timer.h** - Performance measurement
```cpp
namespace utils {
    class ScopedTimer {
        // Logs duration on destruction
    };
}
```

### Module Linking Rules

**Dependencies flow ONE direction:**
```
main.cpp
  ‚Üì
[video, rendering, storage] ‚Üê uses core interfaces
  ‚Üì
platform ‚Üê platform abstraction
  ‚Üì
utils ‚Üê common utilities
```

**Prohibited:**
- ‚ùå utils depending on application modules
- ‚ùå Circular dependencies between modules
- ‚ùå Direct platform-specific code outside platform/

---

## üìÑ FEATURE SPECIFICATION FILES

### Spec File Organization

```
docs/specs/
‚îú‚îÄ‚îÄ video-pipeline.md          # Video capture specification
‚îú‚îÄ‚îÄ osd-rendering.md           # OSD/rendering specification
‚îú‚îÄ‚îÄ file-storage.md            # Storage specification
‚îú‚îÄ‚îÄ platform-abstraction.md    # Platform layer specification
‚îî‚îÄ‚îÄ [feature-name].md          # One spec per feature
```

### Spec File Template

```markdown
# [Feature Name] Specification

**Status:** [Draft | In Progress | Implemented | Tested]
**Last Updated:** [Date]
**Owner:** [Task assignee]

## Overview
Brief description of feature and its purpose.

## Requirements
Functional requirements (FR-XX from PROJECT-SPEC.md)

## Interface Design
```cpp
// Interface definition
class IFeature { ... };
```

## Implementation Details

### Platform Considerations
- macOS: [specifics]
- Jetson: [specifics]

### Dependencies
- [List of required components/interfaces]

### Error Handling
| Error Condition | Behavior | Recovery |
|----------------|----------|----------|
| Camera unavailable | Return false, log error | User retry |

## Configuration
```json
{
  "feature": {
    "param1": "value1"
  }
}
```

## Testing Strategy

### Unit Tests
- [ ] Test initialization
- [ ] Test error conditions
- [ ] Test cleanup

### Integration Tests
- [ ] Test with real camera
- [ ] Test cross-platform

## Performance Requirements
- Latency: < X ms
- CPU: < Y %
- Memory: < Z MB

## Open Questions
- [ ] Question 1
- [ ] Question 2

## Implementation Log
- [Date] - Task completed: [description]
- [Date] - Updated interface: [changes]

## Future Enhancements
- Possible improvement 1
- Possible improvement 2
```

### Spec Update Protocol

**AFTER completing each task:**

1. **Claude Code MUST ask:**
```
Task completed. Should I update the spec?

Changes to document:
- Implemented: [what was done]
- Interface changes: [any modifications]
- New requirements discovered: [if any]
- Performance measured: [actual numbers]

Shall I update docs/specs/[feature].md?
```

2. **Update spec file automatically** (with user approval)
3. **Mark requirements as completed** (‚úÖ)
4. **Add implementation notes**
5. **Record any deviations from original plan**

### Spec-Driven Task Creation

**When starting new feature:**

1. Create spec file FIRST (with user)
2. Define interface in spec
3. Break into tasks
4. Implement task by task
5. Update spec after each task
6. Mark complete when all tasks done

---

## üß™ TEST-DRIVEN DEVELOPMENT

### Test Organization

```
tests/
‚îú‚îÄ‚îÄ unit/                      # Unit tests per module
‚îÇ   ‚îú‚îÄ‚îÄ test_video_pipeline.cpp
‚îÇ   ‚îú‚îÄ‚îÄ test_osd_renderer.cpp
‚îÇ   ‚îî‚îÄ‚îÄ test_platform.cpp
‚îÇ
‚îú‚îÄ‚îÄ integration/               # Integration tests
‚îÇ   ‚îú‚îÄ‚îÄ test_video_to_osd.cpp
‚îÇ   ‚îî‚îÄ‚îÄ test_full_pipeline.cpp
‚îÇ
‚îú‚îÄ‚îÄ mocks/                     # Mock implementations
‚îÇ   ‚îú‚îÄ‚îÄ mock_video_pipeline.h
‚îÇ   ‚îî‚îÄ‚îÄ mock_renderer.h
‚îÇ
‚îî‚îÄ‚îÄ CMakeLists.txt             # Test build config
```

### Test Creation Rules

**For EACH implementation task:**

1. **Create test file** (if doesn't exist)
2. **Write test cases** BEFORE or DURING implementation
3. **Run tests** to verify
4. **Update tests** if interface changes

### Test Template

```cpp
/**
 * @file test_video_pipeline.cpp
 * @brief Unit tests for VideoPipeline class
 */

#include <gtest/gtest.h>
#include "video/video_pipeline.h"
#include "mocks/mock_platform.h"

class VideoPipelineTest : public ::testing::Test
{
protected:
    void SetUp() override
    {
        // Setup before each test
    }

    void TearDown() override
    {
        // Cleanup after each test
    }

    // Test fixtures
    std::unique_ptr<IVideoPipeline> pipeline;
};

TEST_F(VideoPipelineTest, InitializeSucceeds)
{
    // Given
    PipelineConfig config{1280, 720, 30};
    pipeline = createVideoPipeline();

    // When
    bool result = pipeline->initialize(config);

    // Then
    EXPECT_TRUE(result);
    EXPECT_EQ(pipeline->getState(), "initialized");
}

TEST_F(VideoPipelineTest, InitializeFailsWithInvalidConfig)
{
    // Given: invalid resolution
    PipelineConfig config{0, 0, 30};
    pipeline = createVideoPipeline();

    // When
    bool result = pipeline->initialize(config);

    // Then
    EXPECT_FALSE(result);
    EXPECT_EQ(pipeline->getState(), "error");
}

TEST_F(VideoPipelineTest, GetFrameReturnsNullOnTimeout)
{
    // Given: pipeline not started
    pipeline = createVideoPipeline();

    // When
    auto frame = pipeline->getNextFrame(100);  // 100ms timeout

    // Then
    EXPECT_EQ(frame, nullptr);
}
```

### Test Requirements

**Minimum test coverage for each component:**
- ‚úÖ Happy path (normal operation)
- ‚úÖ Error conditions (invalid input, failures)
- ‚úÖ Edge cases (boundary values)
- ‚úÖ Resource cleanup (no leaks)

**Integration tests should verify:**
- ‚úÖ Component interactions
- ‚úÖ End-to-end workflows
- ‚úÖ Platform-specific behavior

### Test Automation

**After implementing feature:**

```bash
# Claude Code should suggest:
"Feature complete. Let's verify:

1. Build tests: cmake --build build --target tests
2. Run tests: ./build/tests/unit_tests
3. Check coverage: [if available]

Should I create a test runner script?"
```

---

## üéì LEARNING & TEACHING MODE

### C++ Concepts to Explain

When using these concepts, **ALWAYS explain**:

**RAII (Resource Acquisition Is Initialization)**
```cpp
// Example with explanation:
class GstPipelinePtr
{
    // TEACHING: RAII ensures resources are cleaned up automatically
    // when object goes out of scope. No manual cleanup needed!
    // This prevents resource leaks even if exceptions occur.
public:
    explicit GstPipelinePtr(GstElement* p) : pipeline_(p)
    {
        // Resource acquired in constructor
    }

    ~GstPipelinePtr()
    {
        // Resource released in destructor - automatic!
        if (pipeline_)
        {
            gst_element_set_state(pipeline_, GST_STATE_NULL);
            gst_object_unref(pipeline_);
        }
    }
    // ... rest
};

// Usage example (show the benefit):
{
    GstPipelinePtr pipeline(gst_parse_launch(...));
    // Use pipeline...
    // No manual cleanup needed - destructor called automatically!
}  // pipeline cleaned up here automatically
```

**Smart Pointers**
```cpp
// TEACHING: Smart pointers manage memory automatically
// - unique_ptr: Single owner, moves ownership
// - shared_ptr: Multiple owners, reference counted
// - No manual delete needed!

// unique_ptr example:
std::unique_ptr<Config> config = std::make_unique<Config>();
// config automatically deleted when goes out of scope

// shared_ptr example (when multiple components need access):
std::shared_ptr<Frame> frame = std::make_shared<Frame>();
// frame deleted when last reference goes away
```

**Move Semantics**
```cpp
// TEACHING: Move semantics transfer ownership without copying
// Useful for large objects (like video frames)

// Instead of copying (slow):
Frame f1 = getFrame();  // Copy - expensive!

// Move ownership (fast):
Frame f1 = std::move(getFrame());  // No copy - just transfer!
```

### Robotics Concepts to Explain

**Pipeline Architecture**
```
TEACHING: Robotics uses pipeline architecture for real-time processing:
Camera ‚Üí Capture ‚Üí Process ‚Üí Render ‚Üí Display
Each stage runs independently, often on separate threads
```

**Latency vs Throughput**
```
TEACHING:
- Latency: Time for single frame to go through pipeline (we want LOW)
- Throughput: Frames per second (we want HIGH)
- Trade-off: Can't always optimize both
```

**Platform Abstraction in Robotics**
```
TEACHING: Robots run on different hardware (Jetson, RPi, x86)
We write code once, but need platform-specific optimizations:
- Camera interfaces differ
- GPU capabilities vary
- CPU architectures different
Solution: Abstract these differences behind interfaces
```

### When to Teach

**Teach when:**
- Using a C++ feature user may not know
- Implementing a robotics pattern
- Making an architectural decision
- Encountering a common pitfall

**Format:**
```cpp
// TEACHING: [Concept name]
// [Brief explanation]
// [Why it matters in this project]
// [Common mistakes to avoid]

// Example code demonstrating concept
```

---

## ‚úÖ CODE REVIEW CHECKLIST

### Before Submitting Code

**Claude Code should verify:**

**Compilation & Warnings**
- [ ] Compiles without errors
- [ ] Zero warnings with `-Wall -Wextra -Wpedantic`
- [ ] No unused variables/functions
- [ ] All includes necessary and sufficient

**Code Quality**
- [ ] Follows naming conventions
- [ ] Proper error handling (all paths)
- [ ] No magic numbers (use named constants)
- [ ] Resource cleanup (RAII pattern)
- [ ] No memory leaks (checked with valgrind if possible)

**Documentation**
- [ ] File header present
- [ ] Public functions documented
- [ ] Complex logic explained in comments
- [ ] Platform-specific notes added

**Testing**
- [ ] Unit tests written
- [ ] Tests pass
- [ ] Edge cases covered
- [ ] Error conditions tested

**Integration**
- [ ] Interfaces match specification
- [ ] Module dependencies clean (no circular)
- [ ] Platform abstraction maintained
- [ ] No platform-specific code outside platform/

**Performance** (if applicable)
- [ ] No obvious performance issues
- [ ] Unnecessary allocations removed
- [ ] Tight loops optimized

**Git**
- [ ] Logical commits (one feature per commit)
- [ ] Meaningful commit messages
- [ ] No committed build artifacts
- [ ] .gitignore updated if needed

### Review Output Format

```markdown
## Code Review Complete

**Status:** [PASS / NEEDS WORK]

### Checks Passed ‚úÖ
- Compilation: Clean
- Warnings: None
- Tests: All passing (12/12)
- Documentation: Complete

### Issues Found ‚ùå
1. **Memory leak in video_pipeline.cpp:45**
   - Issue: GstBuffer not unreffed
   - Fix: Add gst_buffer_unref() after use

2. **Missing error check in renderer.cpp:78**
   - Issue: nvgCreateFont() return not checked
   - Fix: Add if (!font) { error handling }

### Suggestions üí°
- Consider extracting frame conversion to utility function
- Could use std::optional instead of returning nullptr

Proceed with fixes?
```

---

## üîß ADDITIONAL DEVELOPMENT GUIDELINES

### Dependency Management

**Track dependencies explicitly:**

```markdown
## Dependency Graph

### Module Dependencies
- video ‚Üí [platform, utils/logger]
- rendering ‚Üí [platform, utils/logger]
- storage ‚Üí [utils/logger, utils/config_parser]
- main ‚Üí [video, rendering, storage]

### External Dependencies
- GStreamer 1.14+ (required)
- NanoVG (required)
- GLFW3 (required, for window)
- nlohmann/json (optional, for config)
- GoogleTest (optional, for tests)
```

**Before adding new dependency:**
1. Is it necessary?
2. Is it cross-platform?
3. Is it actively maintained?
4. Can we vendor it (include in repo)?

### Performance Benchmarking

**Create benchmarks for critical paths:**

```cpp
// utils/benchmark.h
namespace utils {
    class Benchmark {
        static void measurePipelineLatency();
        static void measureRenderingFPS();
        static void measureMemoryUsage();
    };
}
```

**Run benchmarks:**
- After implementing each major component
- On both macOS and Jetson
- Document results in spec files

### Git Commit Guidelines

**Commit message format:**
```
[component] Brief description

Detailed explanation of what and why.

- Bullet points for specifics
- Reference issue/task if applicable

Affects: video, platform
Tests: Added test_pipeline_init
```

**Examples:**
```
[video] Implement GStreamer pipeline initialization

Added VideoPipeline class with platform abstraction.
Uses gst_parse_launch for dynamic pipeline creation.

- macOS: autovideosrc
- Jetson: nvarguscamerasrc
- Error handling for camera unavailable

Affects: video, platform
Tests: test_video_pipeline.cpp
Spec: docs/specs/video-pipeline.md updated
```

### Refactoring Rules

**When to refactor:**
- Code duplication (DRY violation)
- Function > 50 lines
- Class > 300 lines
- Cyclomatic complexity > 10
- Before adding new feature to messy code

**Refactoring process:**
1. Write tests for current behavior
2. Refactor incrementally
3. Run tests after each change
4. Update documentation
5. Commit refactoring separately

**Never:**
- Mix refactoring with new features
- Refactor without tests
- Make large refactorings at once

### Security Considerations

**For robotics applications:**

**Input Validation**
```cpp
// Validate all external inputs
bool validateConfig(const PipelineConfig& config)
{
    if (config.width <= 0 || config.width > 4096) return false;
    if (config.height <= 0 || config.height > 4096) return false;
    if (config.fps <= 0 || config.fps > 120) return false;
    return true;
}
```

**Resource Limits**
```cpp
// Prevent resource exhaustion
const size_t MAX_BUFFER_COUNT = 10;
const size_t MAX_MEMORY_MB = 256;
```

**Path Traversal Prevention**
```cpp
// Sanitize file paths
std::string sanitizePath(const std::string& path)
{
    // Prevent ../../../etc/passwd
    if (path.find("..") != std::string::npos)
        throw std::invalid_argument("Invalid path");
    return path;
}
```

### Logging Standards

**Log levels:**
```cpp
// DEBUG: Detailed diagnostic info (disabled in release)
utils::log(LogLevel::DEBUG, "video", "Frame captured: 1920x1080");

// INFO: Important state changes
utils::log(LogLevel::INFO, "video", "Pipeline started successfully");

// WARNING: Unexpected but handled
utils::log(LogLevel::WARNING, "video", "Camera not found, using fallback");

// ERROR: Failures requiring attention
utils::log(LogLevel::ERROR, "video", "Failed to initialize: " + error);
```

**What to log:**
- ‚úÖ Initialization/shutdown
- ‚úÖ State changes
- ‚úÖ Errors and warnings
- ‚úÖ Performance metrics (occasionally)

**What NOT to log:**
- ‚ùå Every frame processed (too verbose)
- ‚ùå Sensitive information
- ‚ùå Inside tight loops

### Configuration Management

**Configuration hierarchy:**
```
1. Defaults (in code)
2. Config file (config/settings.json)
3. Command line arguments (override)
4. Environment variables (override)
```

**Example:**
```cpp
PipelineConfig loadConfig()
{
    // 1. Start with defaults
    PipelineConfig config{1280, 720, 30};

    // 2. Load from file if exists
    if (std::filesystem::exists("config/settings.json"))
        config = ConfigParser::loadFromFile("config/settings.json");

    // 3. Override with environment variables
    if (const char* width = std::getenv("VIDEO_WIDTH"))
        config.width = std::stoi(width);

    return config;
}
```

---

## üöÄ WORKFLOW SUMMARY

### Starting a New Feature

1. **Create feature spec** (docs/specs/feature-name.md)
2. **Define interfaces** (src/core/i_feature.h)
3. **Break into tasks** (each 1-2 hours)
4. **For each task:**
   - Evaluate & critique approach
   - Ask clarifying questions
   - Implement with tests
   - Review code
   - Update spec
5. **Integration test**
6. **Performance benchmark**
7. **Mark feature complete**

### Example Task Flow

```
USER: "Let's implement video capture"

CLAUDE CODE:
"Before we start, let me analyze this:

**Evaluation:**
This is a large task. I suggest breaking it into:
1. Task 1: Define IVideoPipeline interface [1h]
2. Task 2: Implement platform detection [1h]
3. Task 3: Implement macOS pipeline [2h]
4. Task 4: Implement Jetson pipeline [2h]
5. Task 5: Add error handling & tests [1h]

**Questions:**
1. Should we support USB cameras on both platforms?
2. What's priority: macOS first, or both in parallel?
3. Do we need camera enumeration (list available cameras)?

**Suggestion:**
Let's start with Task 1 (interface). This defines the contract
and lets us work on macOS/Jetson implementations independently.

Want me to:
A) Create the spec file for video-pipeline.md first?
B) Jump straight to IVideoPipeline interface?
C) Discuss the interface design together first?

What's your preference?"

[User chooses]

[Claude proceeds with chosen approach]

[After completion]

CLAUDE CODE:
"Task 1 complete. Review:

Created:
- docs/specs/video-pipeline.md
- src/core/i_video_pipeline.h
- tests/unit/test_video_pipeline_interface.cpp

Review checklist:
‚úÖ Compiles clean
‚úÖ No warnings
‚úÖ Interface documented
‚úÖ Spec updated
‚úÖ Tests compile (mock implementation for now)

Should I:
1. Update PROJECT-SPEC.md to reference this spec?
2. Move to Task 2 (platform detection)?
3. Review interface design with you first?
"
```

---

## üìã WHAT YOU MIGHT HAVE MISSED (Suggestions)

### Build System Enhancements

**Add to CMake:**
```cmake
# Option to build with/without tests
option(BUILD_TESTS "Build unit tests" ON)

# Option for debug/release logging
option(ENABLE_DEBUG_LOGGING "Enable debug logs" OFF)

# Option for static analysis
option(ENABLE_CLANG_TIDY "Run clang-tidy" OFF)

# Compiler flags for different configs
if(CMAKE_BUILD_TYPE STREQUAL "Debug")
    add_compile_options(-g -O0 -DDEBUG)
else()
    add_compile_options(-O3 -DNDEBUG)
endif()
```

### Continuous Integration

**Consider adding (later):**
- GitHub Actions for automated builds
- Cross-compilation testing
- Automated test runs
- Code coverage reports

### Documentation Generation

**Doxygen integration:**
```cmake
# Generate API docs from comments
find_package(Doxygen)
if(DOXYGEN_FOUND)
    add_custom_target(docs
        COMMAND ${DOXYGEN_EXECUTABLE} Doxyfile
        WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
    )
endif()
```

### Debugging Helpers

**Add debug utilities:**
```cpp
// utils/debug.h
#ifdef DEBUG
    #define DEBUG_PRINT(x) std::cout << "[DEBUG] " << x << std::endl
    #define ASSERT(condition, msg) \
        if (!(condition)) { \
            std::cerr << "Assertion failed: " << msg << std::endl; \
            std::abort(); \
        }
#else
    #define DEBUG_PRINT(x)
    #define ASSERT(condition, msg)
#endif
```

### Performance Profiling

**Add profiling support:**
```cpp
// utils/profiler.h
class ScopedProfiler {
    // Measure and log function execution time
    // Can integrate with tracy or other profilers
};

#define PROFILE_FUNCTION() ScopedProfiler _profiler(__FUNCTION__)
```

### Error Recovery Strategies

**Implement retry logic:**
```cpp
// utils/retry.h
template<typename F>
bool retryOnFailure(F func, int max_attempts = 3, int delay_ms = 1000)
{
    for (int i = 0; i < max_attempts; ++i)
    {
        if (func()) return true;
        std::this_thread::sleep_for(std::chrono::milliseconds(delay_ms));
    }
    return false;
}

// Usage:
bool success = retryOnFailure([&]() {
    return pipeline->initialize(config);
});
```

### Memory Pool for Frames

**For better performance:**
```cpp
// video/frame_pool.h
class FramePool {
    // Pre-allocate frame buffers
    // Reuse instead of allocating each time
    // Reduces GC pressure
};
```

### State Machine for Pipeline

**Explicit state management:**
```cpp
enum class PipelineState {
    Uninitialized,
    Initializing,
    Ready,
    Running,
    Paused,
    Error,
    ShuttingDown
};

class StateMachine {
    // Enforce valid state transitions
    // Prevent invalid operations
};
```

### Metrics Collection

**Runtime metrics:**
```cpp
struct Metrics {
    size_t frames_processed = 0;
    size_t frames_dropped = 0;
    double avg_fps = 0.0;
    double avg_latency_ms = 0.0;
    size_t memory_used_mb = 0;

    void report();  // Log metrics periodically
};
```

### Hot-Reload Configuration

**Reload config without restart:**
```cpp
class ConfigWatcher {
    // Watch config file for changes
    // Reload and apply without restarting app
    // Useful for development and tuning
};
```

---

## üìè CODE QUALITY RULES

### File Size Limits

| Component | Max Lines | Action if Exceeded |
|-----------|-----------|-------------------|
| Source file (.cpp) | 500 | Split into modules |
| Header file (.h) | 300 | Extract interfaces |
| Single function | 50 | Extract sub-functions |
| Single class | 300 | Split responsibilities |

### Code Duplication Prevention

**DRY Principle Enforcement:**

1. **Platform-independent code** - extract to `src/utils/` or `src/core/`
2. **Shared includes** - create wrapper headers (e.g., `core/opengl.h`)
3. **Common validation logic** - move to free functions in header files
4. **Repeated patterns** - create templates or base classes

**When you see duplication:**
```
IF same code appears in 2+ files:
  ‚Üí Extract to utility/helper
IF same logic in platform implementations:
  ‚Üí Move to base class OR free function in platform.h
IF same include pattern:
  ‚Üí Create wrapper header
```

### Utility Extraction Candidates

**Extract to `src/utils/` when code is:**
- Used by 3+ components
- Has no dependencies on application logic
- Could be unit tested in isolation
- Generic enough for reuse

**Standard utilities to maintain:**
| Utility | Purpose |
|---------|---------|
| `utils/opengl.h` | Platform-agnostic OpenGL includes |
| `utils/fps_counter.h` | Frame rate measurement |
| `utils/gstreamer_init.h` | RAII wrapper for GStreamer lifecycle |
| `utils/resolution.h` | Common resolution validation |

### Code Organization Checks

**Before completing any task, verify:**
- [ ] No function exceeds 50 lines
- [ ] No file exceeds 500 lines
- [ ] No code duplicated across files
- [ ] Platform-specific code only in `platform/` directory
- [ ] Utility code properly extracted to `utils/`
- [ ] Common includes wrapped in dedicated headers

### Refactoring Triggers

**Immediate refactoring required when:**
- Same code block appears in 2+ files
- Function exceeds 50 lines
- File exceeds 500 lines
- Cyclomatic complexity > 10
- More than 3 levels of nesting

**Refactoring protocol:**
1. Write/verify tests for current behavior
2. Extract duplicated code to utility
3. Run tests to verify no regression
4. Update all call sites
5. Remove old duplicated code
6. Commit refactoring separately from features

---

## üéØ FINAL REMINDERS

### Every Time Claude Code Responds

**MUST include:**
1. ‚úÖ Task evaluation
2. ‚úÖ Questions/clarifications
3. ‚úÖ Teaching moments (if new concepts)
4. ‚úÖ Code review checklist (after implementation)
5. ‚úÖ Spec update suggestion (after implementation)
6. ‚úÖ Next steps (what to do next)

### Your Mission

Help the developer learn and build a **production-quality** robot vision application that:
- Works cross-platform
- Is well-architected
- Is thoroughly tested
- Is properly documented
- Follows best practices
- Serves as a learning reference

**Quality over speed. Learning over doing.**

---

## üìû HOW TO USE THIS FILE

**For the developer:**
- Read this before starting work
- Reference specific sections as needed
- Use as checklist for tasks
- Update as you learn new patterns

**For Claude Code:**
- Follow these rules for EVERY interaction
- Be a teacher, not just a code generator
- Ask questions before coding
- Critique and suggest improvements
- Help build a great learning experience

---

**End of Configuration**

Version: 2.0 (Enhanced)
Last Updated: December 2025
